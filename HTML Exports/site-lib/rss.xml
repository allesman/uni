<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[eidi]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>eidi</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 03 Feb 2026 09:17:17 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 03 Feb 2026 09:17:16 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Einführung in die Informatik]]></title><description><![CDATA[<a data-href="Altkausuren" href="module/semester-1/eidi/altkausuren.html" class="internal-link" target="_self" rel="noopener nofollow">Altkausuren</a><br>Abstraktionsebene zwischen Dingen außerhalb und innerhalb von Klasse (z.B. Getter und Setter) erleichtert Wartung und <a data-tooltip-position="top" aria-label="Komposition statt Vererbung!" data-href="#Komposition statt Vererbung!" href="einführung-in-die-informatik.html#Komposition_statt_Vererbung!_0" class="internal-link" target="_self" rel="noopener nofollow">Modifikationen am gekapselten Stuff</a>.Modulo Operator funktioniert anders als mathe
++ Zur Gruppierung verwandter Klassen
Alle Klassen in einem File sind in einem Package
Für Package mit mehreren Files: Ordner myPackage machen und die Files darin mit package myPackage; versehen
<br>Bei <a data-tooltip-position="top" aria-label="Primitivity" data-href="#Primitivity" href="einführung-in-die-informatik.html#Primitivity_0" class="internal-link" target="_self" rel="noopener nofollow">Non-Primitive</a> Methodenargumenten übergibt Java Kopien der Referenz. Modifizierung des Objekts (z.B. arr[0]=1) ändert das Original-Objekt im Heap. Reassignment der Variable auf (neues) Objekt (z.B. arr = new int[1]) ändert nur die lokale Kopie der Referenz und hat außen keine Auswirkung.Die Idee (bei Unit-Tests, eigentlich gibts auch noch andere wie z.B. Implementation Tests aber nicht Stoff) ist folgende:
Wir zerhacken unseren Code in die minimalen Bestandteile, idealerweise Funktionen ohne Side-Effects (nur Input und Output) und schreiben für jede Tests, bei denen wir Inputs providen und einen bestimmten Output dafür erwarten. So wissen wir direkt, wo genau der Fehler liegt. Wir schreiben sowohl Tests für das Base-Case (erwartbare Inputs), als auch für Edge Cases (weniger erwartbare Inputs). Eine gute Weise die Test-Cases zu strukturieren sind sogenannte Testklassen, bei denen man mit einer Reihe von Fallunterscheidungen alle möglichen Kombinationen und so alle Situationen abdeckt.Welcome to Reality
Meistens geht das mit dem Zerhacken nicht so schön, weil viele Methoden in der echten Welt inheränt Side-Effects haben (außer man ist auf Hascell-FP-Trip). Ich muss z.B. auf Arbeit oft Unit Tests schreiben für Methoden die auf ne DB zugreifen. Oder die Methode ist abgesehen von den Parametern noch von anderem Stuff abhängig, wie z.B. Datum. Hier braucht man dann Mocking, wodurch man versucht, möglichst nur die Methode im Test zu testen und alles andere zu imitieren und damit abzuschotten.
@Test // Test annotation
public void testForBitFlip(){ int a = 6; int b = 7; int c = a+b; assertEquals(c,13); // assert-Keyword (there's a bunch)
}
<br>Niemals <a data-tooltip-position="top" aria-label="Primitivity" data-href="#Primitivity" href="einführung-in-die-informatik.html#Primitivity_0" class="internal-link" target="_self" rel="noopener nofollow">Non-Primitives</a> mit == vergleichen!
Dann vergleichst du nur deren Referenzen du Dulli. Mach einfach asssertEquals() du Dulli.
auch free außerfor i in zeilen: for j in spalten: skalarprodukt(i,j) skalarprodukt(a,b): for i,j in a,b: output+= i*j
<br>Wird eine Datenstruktur A durch Nutzung einer anderen Struktur B implementiert, ist Vererbung (A extends B) suboptimal, da B nicht <a data-tooltip-position="top" aria-label="Kapselung" data-href="#Kapselung" href="einführung-in-die-informatik.html#Kapselung_0" class="internal-link" target="_self" rel="noopener nofollow">gekapselt</a> bleibt (Bsp: Stack extends ArrayList erbt add(0,x), was LIFO bricht). Durch Komposition (B als Attribut) bleibt man flexibel, falls B später gegen eine andere Struktur ausgetauscht werden soll.Die generische Form A&lt;B&gt; macht primär dann Sinn, wenn B den Typ der in A gespeicherten Elemente definiert (z.B. eine Liste von B-Objekten).<br><a data-href="Collections" href="module/semester-1/eidi/collections.html" class="internal-link" target="_self" rel="noopener nofollow">Collections</a><br><a data-href="Linked List" href="module/semester-1/eidi/linked-list.html" class="internal-link" target="_self" rel="noopener nofollow">Linked List</a><br><a data-href="Polymorphie.pdf" href="module/semester-1/eidi/polymorphie.html" class="internal-link" target="_self" rel="noopener nofollow">Polymorphie.pdf</a><br>
<a data-href="Polymorphism" href="module/semester-1/eidi/polymorphism.html" class="internal-link" target="_self" rel="noopener nofollow">Polymorphism</a><br>Der statische Typ bestimmt die sichtbaren <a data-tooltip-position="top" aria-label="Methodensignatur" data-href="#Methodensignatur" href="einführung-in-die-informatik.html#Methodensignatur_0" class="internal-link" target="_self" rel="noopener nofollow">Methodensignaturen</a> für den Compiler; der dynamische Typ bestimmt die ausgeführte Implementierung der JVM.Name (nicht Return-Type), Parametertypen und Reihenfolge (nicht Namen)
aka public static int method(String hallo, int hallo)Bei A&lt;U extends C&gt; ist die Konstruktion new A&lt;C&gt;() erlaubt, da für die Typprüfung und Generics jede Klasse als Subtyp ihrer selbst betrachtet wird.Ein Compile-Fehler, wenn der Compiler bei überladenen Methoden keine eindeutige Signatur als "besten Match" bestimmen kann.oldStaticType object = new dynamicType();
newStaticType object = (newStaticType) object;
Erstellt ein neues Objekt mit dem alten dynamischen und dem in Klammern angegebenen neuen statischen Typ.
Ein Upcast (von extender auf extendee) schränkt die Sichtbarkeit auf Methoden ein, die im statischen Zieltyp deklariert sind.<br><img alt="Pasted image 20260131162811.png" src="attachments/pasted-image-20260131162811.png" target="_self" style="width: 500px; max-width: 100%;">rekursion schmekursion sag ich immer
<br><a data-href="Binary Tree" href="module/semester-1/eidi/binary-tree.html" class="internal-link" target="_self" rel="noopener nofollow">Binary Tree</a>
<br><a data-href="Binary Search" href="module/semester-1/eidi/binary-search.html" class="internal-link" target="_self" rel="noopener nofollow">Binary Search</a>
<br><a data-href="Recursion" href="module/semester-1/eidi/recursion.html" class="internal-link" target="_self" rel="noopener nofollow">Recursion</a>
]]></description><link>einführung-in-die-informatik.html</link><guid isPermaLink="false">Module/Semester 1/EIDI/Einführung in die Informatik.md</guid><pubDate>Tue, 03 Feb 2026 01:58:08 GMT</pubDate><enclosure url="HTML Exports/attachments/pasted-image-20260131162811.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="HTML Exports/attachments/pasted-image-20260131162811.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>