<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[eidi]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>eidi</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 13 Feb 2026 17:08:28 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 13 Feb 2026 17:08:27 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Einführung in die Rechnerarchitektur]]></title><description><![CDATA[<a href=".?query=tag:era" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#era">#era</a><br>
<a href=".?query=tag:orga" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#orga">#orga</a>
Workflow:
Vorlesung/Moodle -&gt; reine Gliederung (Obsidian)
Bjarne(the goat)-Slides -&gt; Handnotizen
ZÜ-Quizzes
Handnotizen, Bjarne-Tipps -&gt; Obsidian
Tutoriumsaufgaben/Altklausur Grundlage: Relais (Stromkreis durch separaten Strom an/aus öffnen schließen)
Transistor (selbe Funktionsweise, aber nur 3 Kontakte also 1 Stromkreis) "Word" = Basisgröße des Systems (16 bit, 32 bit, etc.) wir benutzen 32 bit Negative Zahlen via Zweierkomplement (Rechnung leichter) Invertierung, + 1
Wertebereich -&gt; positiver Bereich eins kleiner, dafür dabei Kommazahlen via Tupel aus 2 Zahlen (vor und nach Komma)
Floating Point Numbers S: Vorzeichen
F: Nachkommastellen nach 1 (Fraction, Koeffizient, Mantisse, Significant)
E: Verschiebung des Kommas (Abzüglich Bias)
<br>(<a data-footref="1" href="#fn-1-404b1c80a008d7d0" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>) Strings via Ascii (so 8 bit Zahl &lt;-&gt; Buchstabe halt) C-String endet mit dem Byte 0x0 (null-terminiert)
in RV-Assembly mit .asciz
Soweit ich weiß bei uns eher default Pascal String beginnt mit Zahl als Länge
"Der Pascal sagt dir gleich was Sache ist" Vorteil: Verschiedene Versionen jeder Ebene mit jeweils anderen Ebenen kompatibelgcc - C Code -&gt; Kompilierung auf ausführbare Binärdatei
-s: Erzeugt Zwischenergebnis (Assemblersprache)
hexdump - Inhalt der Binärdatei in Hex ausgeben
objdump
-h: teilt in sections ein
-d: Disassemblierung (Binär -&gt; Assemblersprache)
-S: Codiertes Programm mit Bezug auf QuellcodeISA
Instruction Set Architectures
Assemblersprache, Datenkodierungen, Systemeigenschaften, Boot-Up-Prozess
add/sub Ziel, Quelle1, Quelle2
addi Ziel Quelle1, Konst &lt;- max 12 bits
lui lädt obere 20 bits (zusammen mit addi laden von 32 bits)mul multipliziert untere 32 bit
mulh multiply high (multipliziert obere) signed * signed
...su signed unsigned
...u unsigned unsigned
div Division abgerundet
rem Rest
...u unsignedand,or,xor
Für jeden Bit der beiden ZahlenBasically wie Multiplikation/Division, manchmal
sll shift left logical (um drittes argument, aber nur letzte 5 bits), füllt mit 0 auf
...i intermediate (direkt mit supplied 5 bit Zahl)
sr shift right... (zwei Möglichkeit)
...l logical (füllt mit 0 auf)
...a arithmetic (füllt mit 0 auf, aber behält aller ersten bit aka Vorzeichen)Floats mit F-Erweiterung
Doubles mit D-Erweiterung
Eigene Register
fadd,fsub
...dDaten aus dem Hauptspeicher (Arbeitsspeicher) laden
ld load double word (64 bit)
sd store double word
ld destination const(Basisadresse)
Lädt in destination Adresse: Wert vonBasisadresse + constj offset Springe zu aktuell + offset
jr reg, const Springe zu Wert von reg + imm
Beim selbst Schreiben: Sprungmarkenbxx Operand1, Operand2, offset Springe um offset wenn Bedingung true
beq, bne, blt, bge
Andere Richtungen der letzten beiden via Tausch der Operandenjal reg, offset Jump and link, Springe um offset, Speicher Adresse nächsten Befehls in reg+Systembefehle ecall, Eskaliert vom 3
+Input/OutputKeine 1:1-Beziehung von Opcode und Befehl
Pseudobefehle, z.B.
mv rd, rs = add rd, rs, x0
j offset = jal x0, offset
li rd, i = 1.lui rd, i[31:12] 2.addi rd, rd, i[11:0]<br>
-&gt; Wenn i[11]=1, müssen wir lui rd,i[31:12]+1 machen, da addi das i[11:0] dann als negativ interpretiert und das <a data-tooltip-position="top" aria-label="Sign-Extension" data-href="#Sign-Extension" href="einführung-in-die-rechnerarchitektur.html#Sign-Extension_0" class="internal-link" target="_self" rel="noopener nofollow">Zweier-Komplement</a> der Zahl vom Upper Immediate abzieht!
x0: zero
x1-x31:
an: Argument/Return<br>
sn: saved (<a data-tooltip-position="top" aria-label="Caller-/Callee-Saved" data-href="#Caller-/Callee-Saved" href="einführung-in-die-rechnerarchitektur.html#Caller-/Callee-Saved_0" class="internal-link" target="_self" rel="noopener nofollow">by callee</a>)
tn: temporary
ra: return adress<br>
sp: stack pointer (also <a data-tooltip-position="top" aria-label="Caller-/Callee-Saved" data-href="#Caller-/Callee-Saved" href="einführung-in-die-rechnerarchitektur.html#Caller-/Callee-Saved_0" class="internal-link" target="_self" rel="noopener nofollow">callee-saved</a>)Speicherzellen mit Größe entsprechend ISA
Byte-Adressiert (wir können nur ganze Bytes adressieren):Ausrichtung auf n-Byte-Grenze: jede Adresse mod n = 0
Bei RISC-V ist der Stack 16 byte alignedin RISC-V Wechselmöglichkeit, aber wir nutzen Little Endian
Stack meist für Zwischenergebnisse verwendet
meist kleiner als der Heap
wächst meist nach unten (-&gt; Erweitern durch Dekrementierung(!) des SP)
recht einfach zu verwalten (LIFO)
<br><a data-tooltip-position="top" aria-label="Data alignment" data-href="#Data alignment" href="einführung-in-die-rechnerarchitektur.html#Data_alignment_0" class="internal-link" target="_self" rel="noopener nofollow">16 byte aligned</a> Heap meist für dynamische Datenstrukturen verwendet
meist größer als der Stack
wächst meist nach oben
schwerer zu verwalten (Dynamisch) Static Data hat z.B. Konstanten wie verwendete Strings
Text ist der Programmcode
<br><a data-tooltip-position="top" aria-label="Virtueller Speicher (Paging/Mehrere Adressräume)" data-href="#Virtueller Speicher (Paging/Mehrere Adressräume)" href="einführung-in-die-rechnerarchitektur.html#Virtueller_Speicher_(Paging/Mehrere_Adressräume)_0" class="internal-link" target="_self" rel="noopener nofollow">Jedes Programm erhält eigenen Adressraum (für genutzte Daten und Programm selbst)</a><br>Jede Zahl, die mit 1 beginnt (aka in Hex mit &gt;=8 beginnt), ist im <a data-tooltip-position="top" aria-label="Binär" data-href="#Binär" href="einführung-in-die-rechnerarchitektur.html#Binär_0" class="internal-link" target="_self" rel="noopener nofollow">Zweier-Komplement</a> negativ. Wenn wir diesen Zahlen mehr Stellen geben wollen ("größer casten"), gibt es eine wichtige Sache zu beachten: Der Default-Wert für "leere Stellen", die neu hinzukommen, ist bei negativen Zahlen nicht 0, sondern 1. Also füllt man mit 1en auf, wenn bspw. ein 12-bit Immediate auf ein 32-bit Register addiert werden soll.zu "in a0 referenzierter Adresse" Diese Adresse muss also der Caller der Funktion schon mitgeben.
Die tatsächlichen Argumente darf er dann erst ab a1 angeben.
Meist handelt es sich bei der Adresse in a0 um eine innerhalb des Stack-Frames des Callers, so weit Bjarne weiß sogar immer ganz oben (also bei 0(sp)). Prologue Platz auf Stack reservieren (SP dekrementieren(!))
Return Address und andere Variablen auf dem Stack sichern Tatsächlicher Stuff
Epilogue Return Address etc. wieder vom Stack holen
Platz auf Stack freigeben (SP inkrementieren(!))
4 Struktur des Rechners unabhängig von bearbeitetem Problem
Rechner besteht aus vier Werken (die mit Bus-System verbunden sind):
Speicherwerk (RAM)
Leitwerk (CPU)
Rechenwerk (CPU)
Ein-/Ausgabewerk inkl. Sekundärspeicher (Peripherieanschluss, Festplatte)
Hauptspeicher hat Zellen gleiche Größe mit Adressen
Programm &amp; Daten stehen in selbem Speicher und können durch die Maschine verändert werden
Die Maschine nutzt Binär
Programm besteht aus Folge von Befehlen
Von der Folge kann durch Sprünge abgewichen werden
Unterprogrammaufrufe: Register sichern, Parameter supplien
Springen (Jump and Link)
Operation
Zurückspringen (Jump and Link) Unterschied z.B.: Getrennter Speicher für Daten und Programminshallah das kommt in der klausur dran
Machine Mode Babo Modus
<br><a data-href="#Systemaufruf" href="einführung-in-die-rechnerarchitektur.html#Systemaufruf_0" class="internal-link" target="_self" rel="noopener nofollow">Systemaufruf</a> führt kurz hier hin, dann meist Mapping zu S-Mode Supervisor Mode ("Kernel-Level") <br>Hier landen wir meist nach <a data-href="#Systemaufruf" href="einführung-in-die-rechnerarchitektur.html#Systemaufruf_0" class="internal-link" target="_self" rel="noopener nofollow">Systemaufruf</a>
Zugriff auf z.B. Hardware möglich User Mode hier sind wir normalerweise
<br>mit <a data-href="#Systemaufruf" href="einführung-in-die-rechnerarchitektur.html#Systemaufruf_0" class="internal-link" target="_self" rel="noopener nofollow">Systemaufruf</a> können wir aber raus in RISC-V mit ecall<br><img alt="Pasted image 20251104173149.png" src="attachments/pasted-image-20251104173149.png" target="_self" style="width: 500px; max-width: 100%;">shoutout an schulz's roten stift, you won't be missedJedes Programm hat eigenen Speicherraum mit virtuellen Adressen, und nur innerhalb dieses Adressraums Zugriff<br>
Virtuelle Adresse wird immer auf physische übersetzt von MMU (früher Hardware) via Seiten-Kachel-Tabelle (<a data-tooltip-position="top" aria-label="Herausforderungen und Einsatz von Virtuellem Speicher" data-href="#Herausforderungen und Einsatz von Virtuellem Speicher" href="einführung-in-die-rechnerarchitektur.html#Herausforderungen_und_Einsatz_von_Virtuellem_Speicher_0" class="internal-link" target="_self" rel="noopener nofollow">auch mehrere Ebenen möglich</a>)
4KiB Kacheln abgebildet auf 4KiB Kacheln (heutzutage auch größere möglich)
Nur Teil des Adressraums jedes Programms ist tatsächlich im Speicher angelegt, bei Bedarf wird erweitert
Was wenn Programm zugeschriebener Speicher nicht erfüllt werden kann weil keine Kacheln verfügbar? Freimachen beliebiger ( idealerweise lange ungenutzter) Kachel durch Auslagern auf Hintergrundspeicher/FestplatteRealisierung?
Naiv: 1 zusammenhängende Page Table mit komplettem Mapping
-&gt; schneller Zugriff, aber giga Platzbedarf
man müsste ja 1 zusammenhängenden Platz für alle mappings aller Speicherräume reservieren
Based und Sigma: Ebenen mit Tables gemäß Teilen der Adresse
-&gt; viel weniger Platzbedarf
-&gt; aber auch langsamer
(weil nicht Zugriff sondern immer Zugriffe)
-&gt; Allerdings in der Praxis TLB (Cache für Mapping -&gt; weniger Zugriffe)Idealerweise enthält ein möglichst kleiner Zwischenspeicher die als nächstes benötigten Daten, damit schneller auf sie zugegriffen werden kann.
Aber was wird als nächstes benötigt?
zeitliches Lokalitätsprinzip: vor kurzem verwendete Daten
räumliches Lokalitätsprinzip: benachbarte Daten zu zuvor verwendeten
Wie geht dann Schreiben? 2 Möglichkeiten:
Schreiben in den Cache (bei Löschen aus Cache auch Hauptspeicher updaten)
Schreiben in den Hauptspeicher (bei Lesen aus Cache neu aus Hauptspeicher holen)
Was wird wo im Cache gespeichert?
Einteilung Speicheradresse inProblem:
Prozessor A liest Wert mit Adresse 1 aus Hauptspeicher und legt ihn in seinen Cache
Prozessor B schreibt auf Adresse 1 im Hauptspeicher
-&gt; Prozessor A hat falschen Wert im Cache!
Lösung:MESI-Protokoll
Jeder Prozessor merkt sich für jede Adresse, die er im Cache hat, einen der folgenden Zustände
Exclusive: Nur ich habe diese Adresse im Cache
mein Wert im Cache ist valid (entspricht dem Hauptspeicher) Shared: Auch andere haben diese Adresse im Cache
mein Wert im Cache ist valid Modified: Auch andere haben diese Adresse im Cache
mein (neuer, von mir modifizierter) Wert im Cache ist valid
andere haben noch den alten, invalid Wert Invalid: Auch andere haben diese Adresse im Cache
in meinem Cache ist ein veralteter, invalid Wert
ich muss mir beim nächsten Zugriff den neuen valid aus dem Hauptspeicher holen -&gt; Pro Index-Bit Belegung existiert nur 1 Zeile (das zugehörige Set hat nur 1 Zeile)
-&gt; Es kann nur maximal eine Hauptspeicherzeile mit dieser Belegung im Cache sein<br>
-&gt; <a data-tooltip-position="top" aria-label="Conflict Miss" data-href="#Conflict Miss" href="einführung-in-die-rechnerarchitektur.html#Conflict_Miss_0" class="internal-link" target="_self" rel="noopener nofollow">Conflict-Miss</a>-City (passieren dauernd) -&gt; Es gibt nur ein einziges Set, wo jede Hauptspeicherzeile whereever hin kann, weil sie mit ihrem Tag identifiziert wird.<br>
-&gt; Es kann keine <a data-href="#Conflict Miss" href="einführung-in-die-rechnerarchitektur.html#Conflict_Miss_0" class="internal-link" target="_self" rel="noopener nofollow">Conflict Miss</a>es gebenGenerell: Gesuchte Zeile ist momentan nicht im Cache und muss aus dem Hauptspeicher geholt werden (-&gt; delay)Gesuchte Zeile war noch nie im Cache, also muss sie obv aus dem Hauptspeicher geholt werden.<br>Gesuchte Zeile war mal im Cache. Aber sie wurde von anderer Zeile vertrieben, und das obwohl es damals in anderen Sets noch Platz gegeben hätte. Also wäre das in einem <a data-tooltip-position="top" aria-label="Voll-Assoziativ" data-href="#Voll-Assoziativ" href="einführung-in-die-rechnerarchitektur.html#Voll-Assoziativ_0" class="internal-link" target="_self" rel="noopener nofollow">voll-assoziativen</a> Cache nicht passiert.<br>Gesuchte Zeile war mal im Cache. Aber sie wurde von anderer Zeile vertrieben, und es wäre auch nirgends sonst noch Platz gewesen. Also wäre das in einem <a data-tooltip-position="top" aria-label="Voll-Assoziativ" data-href="#Voll-Assoziativ" href="einführung-in-die-rechnerarchitektur.html#Voll-Assoziativ_0" class="internal-link" target="_self" rel="noopener nofollow">voll-assoziativen</a> Cache auch passiert.Hauptspeicher -&gt; L1 -&gt; L2 -&gt; L3
Inklusiv: Alle Daten aus Layer auch in untergeordneten
oder
Exklusiv: Gegenteil, jedes Datum nur in einem Layereasy clap tbhDualer Ausdruck: , sozusagen das Gegenteil eines Ausdrucks
Bilden mit: , , , Basically switch case, 1 Entscheidungseingang und lauter nummerierte Eingänge, von denen der Entscheidungseingang einen aussucht.
In Klausur immer die Nummerierung der Eingänge hinschreiben!Latch -&gt; "latched" onto E (meist Clock), bei E=1 wird D "geschrieben", sonst behält es den letzten valid ZustandFlipFlop -&gt; "schreibt" nur exakt beim Wechsel von E (meist Clock) von 0 auf 1 (bzw. 1 auf 0), sonst behält es den letzten valid Zustand.S-Reduktion
stupid Knoten, der mit allem auf anderen zeigt, kann weg
I-Reduktion
isomorphe Knoten, die sich gleich verhalten, kann man kombinieren<br>Funktion: Formel -&gt; <a data-tooltip-position="top" aria-label="BDD (Binary Decision Diagram)" data-href="#BDD (Binary Decision Diagram)" href="einführung-in-die-rechnerarchitektur.html#BDD_(Binary_Decision_Diagram)_0" class="internal-link" target="_self" rel="noopener nofollow">BDD</a><br>
Wir nehmen immer die entsprechend der Variablenordnung kleinste Variable und erzeugen zwei neue Branches, für die beiden Belegungen der Variable. Auf die neuen Knoten schreiben wir die neue Formel (mit belegter Variable). Das machen wir so lange bis es keine Variablen mehr gibt. Dann nur noch <a data-href="#Reduktionen" href="einführung-in-die-rechnerarchitektur.html#Reduktionen_0" class="internal-link" target="_self" rel="noopener nofollow">Reduktionen</a> benutzen, um zu "kürzen". Fertig ist der Baum!Hat NICHTS mit ITE-Operator an sich zu tun
Idk wer sich dachte, dass man das so nennen soll. Nicht verwirren lassen, wenn man mit dem ITE-Verfahren 3 Bäume mit dem ITE-Operator kombinieren soll.
<br>Funktion: <a data-tooltip-position="top" aria-label="BDD (Binary Decision Diagram)" data-href="#BDD (Binary Decision Diagram)" href="einführung-in-die-rechnerarchitektur.html#BDD_(Binary_Decision_Diagram)_0" class="internal-link" target="_self" rel="noopener nofollow">BDDs</a> kombinieren mithilfe beliebiges Operators
Jeden Knoten unique benennen
Wir starten bei jedem Baum mit dem jeweils obersten Knoten
Loop (solang bis der Wert der Formel feststeht) Neuen Knoten unseres neuen Baums erstellen Mit zugehöriger Formel (Operator auf Knoten der Bäume angewendet)
Wenn es den Knoten mit der Formel schon gibt, können wir ihn wiederverwenden! Bei niedrigste(n) Variablen (gemäß Ordnung) eins runtergehen, um nächste Knoten zu finden Wenn wir einen festen Wert haben, verweist die entsprechende Kante einfach auf 1 oder 0
Dann gehen wir im zu erstellenden Baum so lange hoch, bis ein Pfad fehlt und wieder Loop
<br><a data-href="#Reduktionen" href="einführung-in-die-rechnerarchitektur.html#Reduktionen_0" class="internal-link" target="_self" rel="noopener nofollow">Reduktionen</a> benutzen, um Baum zu "kürzen"
Funktion: Schaltungen auf Äquivalenz Prüfen wenn erfüllbar ist (also wenn es Belegung gibt wo True rauskommt), sind die Schaltungen nicht Äquivalent!
-&gt; Um das zu testen, kann man noch in KNF überführen.Dafür
erstellt man den Syntax-Baum (mit der direkt geht eigentlich auch)
benennt jede Abzweigung mit einer Variable formuliert Das kann man dann noch in KNF auflösen: (ggf. deMorgan anwenden) verbindet alle Terminale in
zusammenhängendem Graphen Hanaan-Punkte finden
alle die auf Spalte und Zeile von Terminalen liegen
Kürzesten Pfad zwischen zwei Terminalen finden
auf den beiden Möglichkeiten verbinden (links und rechtsrum)
Alle Hanaan-Punkte auf diesen Verbindungen markieren
Kürzesten Pfad zwischen Hanaan-Punkt und nächstem Terminal finden (-&gt; 3.)
-&gt; Wenn alle verbunden sind, sind wir fertig yay!
<br>Nur weil wir einen Steinerbaum haben, hat der noch nicht die minimalen Kosten. Dabei handelt es sich dann um ein (NP-hartes) <a data-tooltip-position="top" aria-label="MILP aka Multiple Integer Linear Programming (nicht so easy (NP-hart))" data-href="#MILP aka Multiple Integer Linear Programming (nicht so easy (NP-hart))" href="einführung-in-die-rechnerarchitektur.html#MILP_aka_Multiple_Integer_Linear_Programming_(nicht_so_easy_(NP-hart))_0" class="internal-link" target="_self" rel="noopener nofollow">MILP-Problem</a>Unter Beachtung linearer Bedingungen (z.B. ) möglichst kleinen Wert für eine Formel finden. Meist sind einige Variablen der Lösung nicht ganzzahlig.<br>Wie <a data-tooltip-position="top" aria-label="LP aka Linear Programming (easy)" data-href="#LP aka Linear Programming (easy)" href="einführung-in-die-rechnerarchitektur.html#LP_aka_Linear_Programming_(easy)_0" class="internal-link" target="_self" rel="noopener nofollow">LP</a> aber zudem muss eine bestimmte Teilmenge der Variablen ganzzahlig sein.
<br><a data-tooltip-position="top" aria-label="LP aka Linear Programming (easy)" data-href="#LP aka Linear Programming (easy)" href="einführung-in-die-rechnerarchitektur.html#LP_aka_Linear_Programming_(easy)_0" class="internal-link" target="_self" rel="noopener nofollow">LP</a>-Lösung finden
ist sie auch MILP-Lösung? ja -&gt; perfekt, nächste Lösung finden (-&gt; 1.)
nein -&gt; Werte "runden" indem wir für jeden zu rundenden Wert zwei neue LP-Bedingungen adden
und zwar und So schließen wir den nicht-ganzzahligen Problembereich für diesen Wert quasi aus
dann mit neuen Bedingungen dabei von vorne (-&gt; 1.) Sobald wir alle MILP-Lösungen haben, die mit minimalen Kosten nehmen! <br>TODO Was ist Bias?<a href="#fnref-1-404b1c80a008d7d0" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>Das Wirtschaftsmagazin<a href="#fnref-2-404b1c80a008d7d0" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>einführung-in-die-rechnerarchitektur.html</link><guid isPermaLink="false">Module/Semester 1/ERA/Einführung in die Rechnerarchitektur.md</guid><pubDate>Fri, 13 Feb 2026 16:16:11 GMT</pubDate></item></channel></rss>