---
klausur: "[[(Altklausur 17) oh helll naaaaahhaaah.pdf]]"
date: 2026-01-30
score: 0.72
grade: 0
year: 2017
done: true
---
#altklausur

# Learnings:

| **Kategorie**        | **Lernpunkt**                  | **Erklärung**                                                                                                                                                                                                                                                                                                                                                            |
| -------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Teil 1-2: Einführung | Call-by-Value (Referenzen)     | Java übergibt **Kopien der Referenz**. `arr[0]=1` ändert das **Original-Objekt im Heap**. `arr = new int[1]` ändert nur die **lokale Kopie** der Referenz und hat außen keine Auswirkung.                                                                                                                                                                                |
| Teil 6: Datentypen   | Komposition statt Vererbung    | Wird eine Datenstruktur A durch Nutzung einer anderen Struktur B implementiert, ist **Vererbung (`A extends B`) suboptimal**, da B nicht **gekapselt** bleibt (Bsp: `Stack extends ArrayList` erbt `add(0,x)`, was **LIFO bricht**). Durch **Komposition** (B als Attribut) bleibt man **flexibel**, falls B später gegen eine andere Struktur ausgetauscht werden soll. |
|                      | Generische Datentypen          | Die generische Form **`A<B>`** macht primär dann Sinn, wenn B den **Typ der in A gespeicherten Elemente** definiert (z.B. eine Liste von B-Objekten).                                                                                                                                                                                                                    |
| Teil 7: Polymorphie  | Statischer vs. Dynamischer Typ | Der **statische Typ** bestimmt die sichtbaren **Signaturen** für den Compiler; der **dynamische Typ** bestimmt die ausgeführte **Implementierung** der JVM.                                                                                                                                                                                                              |
|                      | Generics & Bounds              | Bei `A<U extends C>` ist die Konstruktion **`new A<C>()`** erlaubt, da für die Typprüfung und Generics **jede Klasse als Subtyp ihrer selbst** betrachtet wird.                                                                                                                                                                                                          |
|                      | Ambiguity Error                | Ein **Compile-Fehler**, wenn der Compiler bei überladenen Methoden **keine eindeutige Signatur** als "besten Match" bestimmen kann.                                                                                                                                                                                                                                      |
|                      | Casting-Sichtbarkeit           | Ein **Upcast** schränkt die **Sichtbarkeit** auf Methoden ein, die im **statischen Zieltyp** deklariert sind.                                                                                                                                                                                                                                                            |
| Teil 9: Streams      | Speichereffizienz              | Streams sind **lazy** und verarbeiten Daten **"on-the-fly"**, was sie **speichereffizienter** macht als persistente Collections im RAM.                                                                                                                                                                                                                                  |
|                      | Seiteneffekte in Streams       | Um **Objektattribute** während des Durchlaufs zu **aktualisieren**, können Operationen wie **`map()` oder `peek()`** genutzt werden.                                                                                                                                                                                                                                     |
| Teil 10: Threads     | Heap & JVM Architektur         | Code läuft in der JVM; auch bei mehreren Threads gibt es logisch nur **einen gemeinsamen Heap** auf einem Core.                                                                                                                                                                                                                                                          |
|                      | Thread-Stacks                  | Jeder Thread besitzt trotz des gemeinsamen Heaps einen **eigenen, privaten Stack** für lokale Variablen.                                                                                                                                                                                                                                                                 |
# Bearbeitung
![[(Altklausur 17) oh helll naaaaahhaaah.pdf]]